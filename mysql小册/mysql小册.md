### 2.Mysql的客户端/服务器架构



### 3.Mysql的调控按钮——启动选项 和 系统变量



### 4.乱码的前世今生——字符集 和 比较规则

------

- 字符集

计算机只能存储二进制数据，所以要存储字符串就必须建立字符与二进制的映射关系



- 比较规则

确定了编码范围后，就需要确定字符之间的比较规则，进行数据的匹配，比如你要查询的数据在数据库中搜索后进行比对后得到查询结果，怎么比较两个字符的大小呢？

最容易想到的是比较两个字符的二进制编码的大小，但二进制比较虽然简单，但有时候并不符合需求，比如有的情况下我们需要的数据并不区分大小写，比如**’a‘**和**’A‘**是一样大的，这个时候二进制比较这种**比较规则**就失效了，于是，我们可以定义一下比较规则：

1.将他们同时转化为大写或小写

2.在比较这两个字符对应的二进制数据



一个字符集可以对应多个比较规则，



- Mysql支持的字符集和比较规则

  查看mysql支持的字符集命令

```mysql
show charset;   //有很多，可以用like省略一些
```

​		查看mysql支持的比较规则

```mysql
show collation like 'utf8\_%';  //这里查询的是字符集utf8对应的比较规则
```



- 各个几级别的字符集和比较规则
  - 服务器级别
  - 数据库级别
  - 表级别
  - 列级别



### 5.从一条记录说起--InooDB记录结构

- InooDB页的概念

InooDB是一个将表中的数据存储到磁盘上的存储引擎，但处理数据是发生在内存中的，所以要把磁盘上的数据加载到内存中，或者是处理完请求后，将数据从内存中刷新到磁盘上。

但是读取磁盘非常的慢，和读取内存差几个数量级，所以在我们想要获取记录时，一条一条从磁盘上读取是不现实的，太慢了。。。因此

InooDB采取的方式是：**将数据划分为若干个页**，以页作为内存和磁盘交互的基本单位，InooDB中页的大小一般为16KB。也就是一般情况下会把16KB的数据从磁盘中读取到内存，或者是将内存中16KB的数据刷新到磁盘。



- InooDB行格式

我们平时是以记录为单位来向表中插入数据的，这些记录在磁盘上的存储方式被称为**行格式**或者**记录格式**。InooDB存储引擎的设计者设计了4种不同类型的行格式，分别是Compact，Redundant, Dynamic, Compressed行格式。行格式的原理大多相同。



- ##### COMPACT行格式

一条**完整的记录**可以分为**记录的额外信息**和**记录的真实信息**两大部分

![169710e8fafc21aa](/Users/zhangkuang/Documents/Desk/kuangkaungkaungha/Notes/mysql小册/169710e8fafc21aa.webp)

- 记录的额外信息

这部分信息是服务器为了描述这条记录而不得不添加的一些信息，这些额外信息分为3类，别是**变长字段长度列表**，**null值列表**，和**记录头信息**

------

##### 	

##### 1）变长字段长度列表

我们知道mysql支持一些变长的数据类型，比如varchar，varbinary，各种text和各种biob类型，我们可以把拥有这些数据类型的字段成为**变长字段**，变长字段存储多少字节的数据是不固定的，所以我们在存储真实数据时需要顺便吧这些数据占用的字节数也存起来，这样才不至于把MYSQL服务器搞懵，所以这些变长字段占用的存储空间分为两部分：

1. 真正的数据内容
2. 占用的字节数



在Compact行格式中，把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而**形成了一个变长字段长度列表**，各变长字段数据占用的字节数按照列的数据**逆序排放**！！！

这是一条记录

![169710e8fb363bb4](/Users/zhangkuang/Desktop/169710e8fb363bb4.webp)

![169710e8fb363bb4](/Users/zhangkuang/Documents/Desk/kuangkaungkaungha/Notes/mysql小册/169710e8fb363bb4.webp)

关于W、M和L的意思

1. 假设某个字符集中表示一个字符最多需要使用的字节数为**W**，也就是使用**show charset**语句中结果的**maxlen**列的值，比如说**utf8字符集**的 **W** 是3， **gbk字符集**的 **W** 是2， **ascii字符集**中的 **W**是1。

   

2. 对于变长类型**varchar（M）**来说， 这种类型表示最多能存储**M**个字符（非字节），所以这个类型表示的字符串最多能占用的字节数就是 **M*W**  (可以想象成一个字符数组)



  3.假设它实际存储字符串的长度是**L**

（255 127数字问题？）





##### **2）NULL值列表**

我们知道表中的某些列可能存在Null值，如果把这些**NULL**值存入**记录的真实数据中**也会很占地方，所以**Compact行形式**把它们统一管理起来，存储到**NULL值列表**中，它的处理过程如下：

1. 首先统计表中允许存储NULL的列有哪些
2. 对于表中没有允许存储NULL的列，那么**NULL值列表**也就不存在了，否则将每个允许存储NULL的列对应一个二进制数，二进制位按照列的顺序逆序排列，意义如下：1表示该列的值为NULL，0表示不为NULL
3. MYSQL规定NULL值列表必须用**整数个字节**（一个字节，两个字节）的位来表示，如果使用的二进制位个数不是整数个字节，则在字节的高位补0。

![169710e944a8af0c](/Users/zhangkuang/Documents/Desk/kuangkaungkaungha/Notes/mysql小册/169710e944a8af0c.webp)

![169710e95903144f](/Users/zhangkuang/Documents/Desk/kuangkaungkaungha/Notes/mysql小册/169710e95903144f.webp)





##### 3）记录头信息

除了**变长字段长度列表**，NULL值列表之外，还有一个用于描述记录的**记录头信息**，它又固定的**5个字节**组成。

共40位，不同的位代表不同的含义，如图：

![169710e97718ef01](/Users/zhangkuang/Documents/Desk/kuangkaungkaungha/Notes/mysql小册/169710e97718ef01.webp)

各字段具体含义后面解释。。。（就在下一节记录头的秘密里面）



- 记录的真实数据

对于自定义表record_compact_demo来说，记录的真实数据除了（c1,c2,c3,c4）这些我们自定的列，MYSQL还会为每个记录默认添加一些列（也称为隐藏列）：如下

![169710e973b70372](/Users/zhangkuang/Documents/Desk/kuangkaungkaungha/Notes/mysql小册/169710e973b70372.webp)

Row_id  , transaction_id, roll_pointer



- #### **Redundant行格式**

。。。。







### 6.存放数据的大盒子——InooDB数据页结构

- 不同类型的页介绍

InooDB为了许多**不同的目的**而设计了许多**不同类型的页**，现在我们主要讨论的是那些存储我们表中记录的那种类型的页，官方将这种存放数据的页成为**索引页**（index）。一下暂时称为数据页。



- 数据页结构的快速浏览（好像就是一张数据表）

数据页这块16KB大小的存储空间可以被划分为多个部分，不同部分有不同的功能，各个部分如图所示：

<img src="/Users/zhangkuang/Documents/Desk/kuangkaungkaungha/Notes/mysql小册/16f13ee1e2dfac7c.webp" alt="16f13ee1e2dfac7c" style="zoom: 33%;" />

一个InooDB的数据页大概被分为7个部分，具体信息如下：

<img src="/Users/zhangkuang/Documents/Desk/kuangkaungkaungha/Notes/mysql小册/Snipaste_2021-07-27_22-09-15.png" alt="Snipaste_2021-07-27_22-09-15" style="zoom:33%;" />



- 记录在页中的存储

在页的7个部分中，我们自己存储的记录会按照我们指定的行格式存储到User Records中，但刚开始数据页中是没有User Records这个部分的，之后每当有记录插入请求来到时，Free Space就会为这条记录申请一定的存储空间，当Free Records的空间全部被User Records替代时，就意味着这个数据页使用完了，如果还有新的数据要插入时，就要去申请新的数据页了。

<img src="/Users/zhangkuang/Documents/Desk/kuangkaungkaungha/Notes/mysql小册/16a95c0fe86555ed.webp" alt="16a95c0fe86555ed" style="zoom: 67%;" />

为了更好的管理在User Records的这些记录，InnoBD花了很大的心思，

这就要从记录**行格式**的**记录头信息**说起



- 记录头信息的秘密

以下是一条记录的信息简略图（只保留了一些接下来要讨论的**记录头信息**字段和列值）

![16a95c0ff1ae5364](/Users/zhangkuang/Documents/Desk/kuangkaungkaungha/Notes/mysql小册/16a95c0ff1ae5364.webp)

记录头信息里每个字段代表的意义书里分别详细介绍了

1. 





- #### Page Direction（页目录）

现在我们知道记录在页中按照主键值按照由小到大顺序串联成一个单链表，如果我们想查找某条记录，一个比较笨的方法是将这个链表遍历一遍，但是如果一个页中的数据有很多，这样查找对性能是会有损耗的，因此，InooDB的设计者们相想出了更好的方法。

我们平常想从一本书中查找内容时，通常会先翻目录，根据目录的页数找到对应的内容，InnoDB的设计者们为我们的记录页设计了一个类似的目录，他们的制作过程是这样的：



1. 将所有正常的记录（包括最大记录和最小记录，不包括标记为已删除的记录）划分为几个组
2. 每个组的最后一条**记录**（也就是改组内最大的那条记录）的**记录头信息**中的n_owned字段表示**该记录拥有多少条记录**，也就是这组内有多少条记录。
3. 将每个组的最后一条记录的**地址偏移量**（一条记录到下一条记录的所需移动的字节数）单独提取出来，放到**数据页的页尾**，这个地方就是所说的Page Direction，页目录（如下图，真的很像一本书）（回头看看数据页结构图，确实）。页面中这些地址偏移量称为**槽**（Slot），所以这个页目录就是由**槽**构成的。



<img src="/Users/zhangkuang/Documents/Desk/kuangkaungkaungha/Notes/mysql小册/16a95c10c57164a6.webp" alt="16a95c10c57164a6" style="zoom: 50%;" />

看**n_owned**这个字段，它的含义是当前字段所拥有的的记录数，最小记录中的n_owned是1，最大记录中是5，可以看成看成是分组后这组内的记录数。

关于最大记录和最小记录：

设计InnDB的大叔们是有规定的，对于**最小记录所在的组**内只能有1条记录，**最大记录所在的组**里最多只能有8条记录，**其他记录的组**内只能有4-8条记录，所以数据分组的步骤是这样进行的：

1. 初始情况下数据页中只有最小记录和最大记录，它们属于两个分组
2. 之后每插入一条记录，就会从**页目录**中找到**比本记录主键值大且相差最小**的的**槽**，然后把该槽对应的记录的n_owned加1，表示该记录又新增一条记录，知道该值等于8.
3. 在一个组的记录数等于8个后在插入一条记录，这是会将这个组拆分成两个组，一个组4条记录，一个组5条记录，并在页目录中多增加一个槽，这个槽的值就是新增分组中最大记录的地址偏移量。



关于在数据页中快速查找记录的过程：

1. 通过二分法确定该记录所在的槽，并找到该槽所在分组中主键值最小的那条记录。
2. 通过记录的next_record属性遍历该槽所在分组的各个记录。



- #### Page header（文件头部）

InnoDB的设计者们为了得到一个数据页中存储的记录的状态信息，比如在本页中已经存储了多少条记录，第一条记录的地址是什么，页目录存储了多少个槽等等，特意在**数据页结构**中定义了一个叫Page Header部分，他是页的第二部分，占用固定的56个字节，用来专门存储数据页中的状态信息，具体的各个字段的含义看下表：

<img src="/Users/zhangkuang/Documents/Desk/kuangkaungkaungha/Notes/mysql小册/Snipaste_2021-07-28_11-48-47.png" alt="Snipaste_2021-07-28_11-48-47" style="zoom: 33%;" />





- #### File Header（文件头部）

上面的**Page Header** 描述的是针对数据页的记录存储信息，现在描述的**File Header**对于各种类型的页都适用，也就是说**各种页结构**都会以**File Header**作为第一个组成部分，他描述的是各种页都通用的一些信息，比如这个页的编号是多少，它的上一页是谁，下一页是谁吧啦吧啦的，这个部分占用固定的39个字节，下面是它各个字段的含义：

<img src="/Users/zhangkuang/Documents/Desk/kuangkaungkaungha/Notes/mysql小册/Snipaste_2021-07-28_12-02-20.png" alt="Snipaste_2021-07-28_12-02-20" style="zoom:33%;" />



这是不同类型的页，我们说的数据页就是这个索引页

<img src="/Users/zhangkuang/Documents/Desk/kuangkaungkaungha/Notes/mysql小册/Snipaste_2021-07-28_12-05-24.png" alt="Snipaste_2021-07-28_12-05-24" style="zoom:33%;" />

每个数据页都有上一页和下一页两个属性，所有的数据页会组成一个双向链表



- #### File Trailer

我们知道InnoDB存储引擎会将数据存储到磁盘，但是磁盘速度太慢，需要以页为单位把数据加载到内存中处理如果该页中的数据在内存中被修改了，那么修改后的某个时间需要数据刷新到磁盘上。如果刷新一半断电了怎么办，这不是莫名尴尬么？为了检测一个页是否完整（也就是中途断电的情况），InnoDb的设计者们为每个页的页尾都加了一个File Trailer，部分，占用8个字节，可分为两部分：

1. 前4个字节代表**页的**校验和
2. 后4个字节代表页面被最后修改时对应的日志序列位置（LSN）



File Trailer也是对各种类型的页通用的。